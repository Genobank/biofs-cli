import chalk from 'chalk';
import ora from 'ora';
import * as fs from 'fs';
import * as path from 'path';
import { GenoBankAPIClient } from '../lib/api/client';
import { BioCIDResolver } from '../lib/biofiles/resolver';
import { BioFilesCacheManager } from '../lib/storage/biofiles-cache';
import { Logger } from '../lib/utils/logger';
import { VCFFingerprint } from '../lib/genomics/vcf-fingerprint';

export interface ShareOptions {
  lab: string;
  license?: 'non-commercial' | 'commercial' | 'commercial-remix';
  skipSequentias?: boolean;
  skipStory?: boolean;
  verbose?: boolean;
  debug?: boolean;
}

export async function shareCommand(
  biocidOrFilename: string,
  options: ShareOptions
): Promise<void> {
  const api = GenoBankAPIClient.getInstance();
  const resolver = new BioCIDResolver();

  // Validate lab wallet address
  if (!options.lab || !options.lab.match(/^0x[a-fA-F0-9]{40}$/)) {
    Logger.error('Invalid lab wallet address. Must be a valid Ethereum address (0x...)');
    throw new Error('Invalid lab wallet address');
  }

  const licenseType = options.license || 'non-commercial';

  console.log(chalk.cyan('\nğŸ” Preparing biofile for sharing...\n'));
  console.log(`${chalk.gray('File:')} ${biocidOrFilename}`);
  console.log(`${chalk.gray('Lab:')} ${options.lab}`);
  console.log(`${chalk.gray('License:')} ${licenseType}\n`);

  try {
    // Step 1: Verify lab is approved
    const spinner1 = ora('Verifying lab authorization...').start();
    const labs = await api.getApprovedLabs();
    const lab = labs.find(l => l.wallet_address.toLowerCase() === options.lab.toLowerCase());

    if (!lab) {
      spinner1.fail();
      Logger.error(`Lab ${options.lab} is not in the approved labs registry`);
      Logger.info(`Run 'biofs labnfts' to see approved labs`);
      throw new Error('Lab not authorized');
    }

    spinner1.succeed(`Lab verified: ${chalk.green(lab.name)}`);

    // Step 2: Resolve file and check if already tokenized
    const spinner2 = ora('Checking file tokenization status...').start();

    // Try cache first for faster resolution
    const cacheManager = new BioFilesCacheManager();
    const cachedFile = cacheManager.findByIdentifier(biocidOrFilename);

    let fileInfo;
    try {
      if (cachedFile && cachedFile.locations.s3) {
        // Use cached file info
        spinner2.info(`File found in cache: ${cachedFile.metadata.file_type || 'genomic'} file`);
        Logger.debug(`Using cached S3 path: ${cachedFile.locations.s3}`);

        fileInfo = await resolver.resolve(biocidOrFilename);
      } else {
        // Not in cache or no S3 path - use resolver
        fileInfo = await resolver.resolve(biocidOrFilename);
        spinner2.info(`File found: ${fileInfo.type} storage`);
      }
    } catch (error) {
      spinner2.fail();
      Logger.error(`File not found: ${biocidOrFilename}`);
      throw error;
    }

    // Step 3: Mint dual NFTs if needed
    let biocid: string = '';
    let ipAssetId: string = '';

    // Check if file already has BioCID
    const existingBiocid = await api.checkExistingBiocid(biocidOrFilename);

    if (existingBiocid && !options.skipSequentias) {
      console.log(`\n${chalk.green('âœ“')} File already has BioCID: ${chalk.cyan(existingBiocid.biocid)}`);
      biocid = existingBiocid.biocid;
      ipAssetId = existingBiocid.story_ip_id || '';
    } else {
      console.log(`\n${chalk.yellow('âš ï¸')}  File not yet tokenized as BioNFT`);
      console.log(chalk.cyan('ğŸ¨ Initiating dual NFT minting...\n'));

      // Step 3a: Mint BioCID on Sequentias
      if (!options.skipSequentias) {
        console.log(chalk.bold('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”'));
        console.log(chalk.bold('â”‚ Step 1/4: Minting BioCID on Sequentias Network â”‚'));
        console.log(chalk.bold('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜'));

        // Calculate DNA fingerprint and file hash locally (for genomic files)
        let dnaFingerprint: string | undefined;
        let fileHash: string | undefined;

        const isGenomicFile = biocidOrFilename.endsWith('.vcf') || biocidOrFilename.endsWith('.vcf.gz') ||
                              biocidOrFilename.endsWith('.sqlite') || biocidOrFilename.endsWith('.txt') ||
                              fileInfo.path?.endsWith('.vcf') || fileInfo.path?.endsWith('.sqlite');

        if (isGenomicFile) {
          const spinnerFingerprint = ora('Calculating DNA fingerprint and file hash...').start();
          try {
            // Check if file exists locally
            let localFilePath: string | null = null;

            // Try current directory
            if (fs.existsSync(biocidOrFilename)) {
              localFilePath = biocidOrFilename;
            }
            // Try absolute path
            else if (path.isAbsolute(biocidOrFilename) && fs.existsSync(biocidOrFilename)) {
              localFilePath = biocidOrFilename;
            }
            // Try user's home directory common genomics locations
            else {
              const homePath = path.join(process.env.HOME || process.env.USERPROFILE || '', biocidOrFilename);
              if (fs.existsSync(homePath)) {
                localFilePath = homePath;
              }
            }

            if (localFilePath) {
              // Calculate locally
              const fingerprinter = new VCFFingerprint();

              // Calculate DNA fingerprint
              dnaFingerprint = await fingerprinter.processFile(localFilePath);

              // Calculate file hash
              fileHash = VCFFingerprint.calculateFileHash(localFilePath);

              spinnerFingerprint.succeed(`DNA fingerprint calculated (SNP-30-MARKERS) from local file`);
            } else {
              // File not found locally - use placeholders
              spinnerFingerprint.info('File not found locally - DNA fingerprint will be calculated server-side');
            }
          } catch (error) {
            spinnerFingerprint.warn(`Could not calculate fingerprint: ${error instanceof Error ? error.message : error}`);
          }
        }

        const spinnerSeq = ora('Minting BioCID NFT on Sequentias...').start();

        // Determine genomic file type from filename
        let genomicFileType = 'genomic';
        if (biocidOrFilename.endsWith('.vcf') || biocidOrFilename.endsWith('.vcf.gz')) {
          genomicFileType = 'variant';
        } else if (biocidOrFilename.endsWith('.bam')) {
          genomicFileType = 'alignment';
        } else if (biocidOrFilename.endsWith('.fastq') || biocidOrFilename.endsWith('.fq')) {
          genomicFileType = 'reads';
        }

        try {
          const sequentiasResult = await api.mintSequentiasBioCID({
            filename: biocidOrFilename,
            file_type: genomicFileType,
            s3_path: fileInfo.path || '',
            dna_fingerprint: dnaFingerprint,
            file_hash: fileHash
          });

          biocid = sequentiasResult.biocid;

          spinnerSeq.succeed();
          console.log(`${chalk.gray('ğŸ”— Network:')} Sequentias Mainnet`);
          console.log(`${chalk.gray('ğŸ†” BioCID:')} ${chalk.cyan(biocid)}`);
          console.log(`${chalk.gray('ğŸ“ Biorouter:')} ${sequentiasResult.biorouter_address}`);
          console.log(`${chalk.gray('â›“ï¸  Tx Hash:')} ${sequentiasResult.tx_hash}`);
          console.log(chalk.green('âœ… Sequentias BioCID NFT minted!\n'));
        } catch (error) {
          spinnerSeq.fail();
          Logger.error(`Failed to mint Sequentias BioCID: ${error}`);
          throw error;
        }
      }

      // Step 3b: Register IP Asset on Story Protocol
      if (!options.skipStory) {
        console.log(chalk.bold('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”'));
        console.log(chalk.bold('â”‚ Step 2/4: Registering IP Asset on Story        â”‚'));
        console.log(chalk.bold('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜'));

        const spinnerStory = ora('Registering IP Asset on Story Protocol...').start();

        try {
          const storyResult = await api.registerIPAssetWithBiocid({
            biocid: biocid!,
            filename: biocidOrFilename,
            file_type: fileInfo.type
          });

          ipAssetId = storyResult.ip_id;

          spinnerStory.succeed();
          console.log(`${chalk.gray('ğŸ”— Network:')} Story Protocol (Odyssey)`);
          console.log(`${chalk.gray('ğŸ¨ Collection:')} ${storyResult.collection_name}`);
          console.log(`${chalk.gray('ğŸ†” IP Asset ID:')} ${chalk.cyan(ipAssetId)}`);
          console.log(`${chalk.gray('â›“ï¸  Tx Hash:')} ${storyResult.tx_hash}`);
          console.log(chalk.green('âœ… Story Protocol IP Asset registered!\n'));
        } catch (error) {
          spinnerStory.fail();
          Logger.error(`Failed to register Story IP Asset: ${error}`);
          throw error;
        }

        // Step 3c: Attach PIL License Terms
        console.log(chalk.bold('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”'));
        console.log(chalk.bold('â”‚ Step 3/4: Attaching PIL License Terms          â”‚'));
        console.log(chalk.bold('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜'));

        const spinnerLicense = ora('Attaching license terms...').start();

        try {
          const licenseResult = await api.attachLicenseTerms({
            ip_id: ipAssetId,
            license_type: licenseType
          });

          spinnerLicense.succeed();
          console.log(`${chalk.gray('ğŸ“œ License Type:')} ${licenseType}`);
          console.log(`${chalk.gray('ğŸ†” License Terms ID:')} ${licenseResult.license_terms_id}`);
          console.log(`${chalk.gray('â›“ï¸  Tx Hash:')} ${licenseResult.tx_hash}`);
          console.log(chalk.green('âœ… License terms attached!\n'));
        } catch (error) {
          spinnerLicense.fail();
          Logger.error(`Failed to attach license terms: ${error}`);
          throw error;
        }
      }
    }

    // Step 4: Mint License Token to Lab
    console.log(chalk.bold('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”'));
    console.log(chalk.bold('â”‚ Step 4/4: Minting License Token to Lab         â”‚'));
    console.log(chalk.bold('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜'));

    const spinnerToken = ora('Minting license token...').start();

    try {
      const tokenResult = await api.shareWithLab({
        ip_id: ipAssetId!,
        lab_wallet: options.lab,
        license_type: licenseType
      });

      spinnerToken.succeed();
      console.log(`${chalk.gray('ğŸ¥ Recipient:')} ${lab.name} (${formatWallet(options.lab)})`);
      console.log(`${chalk.gray('ğŸ« License Token ID:')} ${tokenResult.license_token_id}`);
      console.log(`${chalk.gray('â›“ï¸  Tx Hash:')} ${tokenResult.tx_hash}`);
      console.log(chalk.green('âœ… License token granted!\n'));
    } catch (error) {
      spinnerToken.fail();
      Logger.error(`Failed to mint license token: ${error}`);
      throw error;
    }

    // Success summary
    const summary = [
      chalk.bold.green('ğŸ‰ Biofile Successfully Shared!'),
      '',
      `${chalk.gray('BioCID (Sequentias):')}`,
      chalk.cyan(`${biocid}`),
      '',
      `${chalk.gray('IP Asset (Story Protocol):')}`,
      chalk.cyan(`https://explorer.story.foundation/ipa/${ipAssetId}`),
      '',
      `${chalk.gray('Lab can now access via:')}`,
      chalk.gray(`$ biofs download --biocid ${biocid}`)
    ].join('\n');

    console.log(chalk.green('\n' + 'â”€'.repeat(60)));
    console.log(summary);
    console.log(chalk.green('â”€'.repeat(60) + '\n'));

    // Update cache with new sharing information
    try {
      cacheManager.upsertBioFile({
        filename: biocidOrFilename,
        locations: {
          s3: fileInfo.path,
          biocid: biocid,
          story_ip: ipAssetId,
          avalanche_biosample: undefined,
          local_path: cachedFile?.locations.local_path
        },
        metadata: {
          file_type: cachedFile?.metadata.file_type,
          size: cachedFile?.metadata.size,
          created_at: cachedFile?.metadata.created_at,
          tokenized: true,
          shared_with: [options.lab],
          license_type: licenseType,
          fingerprint: cachedFile?.metadata.fingerprint,
          file_hash: cachedFile?.metadata.file_hash
        }
      });
      Logger.debug('Cache updated with sharing information');
    } catch (error) {
      Logger.debug(`Failed to update cache: ${error}`);
    }

  } catch (error) {
    Logger.error(`Share failed: ${error}`);
    throw error;
  }
}

function formatWallet(wallet: string): string {
  if (wallet.length === 42) {
    return `${wallet.slice(0, 6)}...${wallet.slice(-4)}`;
  }
  return wallet;
}
