import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { CONFIG } from '../config/constants';
import { CredentialsManager } from '../auth/credentials';
import { ApiResponse, FileInfo, FileWithURL, IPAsset, Biosample } from '../../types/api';
import { Logger } from '../utils/logger';

export class GenoBankAPIClient {
  private static instance: GenoBankAPIClient;
  private axios: AxiosInstance;
  private credManager: CredentialsManager;

  private constructor() {
    this.credManager = CredentialsManager.getInstance();
    this.axios = axios.create({
      baseURL: CONFIG.API_BASE_URL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }

  static getInstance(): GenoBankAPIClient {
    if (!GenoBankAPIClient.instance) {
      GenoBankAPIClient.instance = new GenoBankAPIClient();
    }
    return GenoBankAPIClient.instance;
  }

  private async getSignature(): Promise<string> {
    const creds = await this.credManager.loadCredentials();
    if (!creds) {
      throw new Error('Not authenticated. Please run "genobank login" first.');
    }
    return creds.user_signature;
  }

  // Authentication
  async recover(signature: string): Promise<{ wallet: string }> {
    const response = await this.axios.get('/recover', {
      params: { signature }
    });
    return response.data;
  }

  async validateRootUser(signature: string): Promise<boolean> {
    try {
      const response = await this.axios.get('/validate_root_user', {
        params: { signature }
      });
      return response.data.status === 'Success';
    } catch {
      return false;
    }
  }

  // Files
  async getMyUploadedFileList(): Promise<FileInfo[]> {
    const signature = await this.getSignature();
    const response = await this.axios.get<ApiResponse<FileInfo[]>>('/get_my_uploaded_file_list', {
      params: { user_signature: signature }
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || [];
    }
    throw new Error(response.data.status_details?.message || 'Failed to get file list');
  }

  async getMyUploadedFilesUrls(filter?: string): Promise<FileWithURL[]> {
    const signature = await this.getSignature();
    const params: any = { user_signature: signature };
    if (filter) params._filter = filter;

    try {
      const response = await this.axios.get<ApiResponse<FileWithURL[]>>('/get_my_uploaded_files_urls', {
        params
      });

      if (response.data.status === 'Success') {
        return response.data.status_details?.data || [];
      }
      // Return empty array if failed instead of throwing
      return [];
    } catch (error) {
      // Return empty array on error - user might not have files yet
      return [];
    }
  }

  async getPresignedLink(s3Path: string): Promise<string> {
    const signature = await this.getSignature();
    const response = await this.axios.post<ApiResponse<{ url: string }>>('/get_presigned_link', {
      user_signature: signature,
      s3_path: s3Path
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data?.url || '';
    }
    throw new Error('Failed to get presigned URL');
  }

  async streamFile(filename: string, fileType?: string): Promise<string> {
    const signature = await this.getSignature();
    const params: any = {
      user_signature: signature,
      filename
    };
    if (fileType) params.file_type = fileType;

    // Return the stream URL
    return `${CONFIG.API_BASE_URL}/stream_file?${new URLSearchParams(params).toString()}`;
  }

  async uploadDatasetChunk(
    chunk: Buffer,
    metadata: {
      filename: string;
      chunkIndex: number;
      totalChunks: number;
      fileType?: string;
    }
  ): Promise<void> {
    const signature = await this.getSignature();
    const FormData = require('form-data');
    const form = new FormData();

    form.append('user_signature', signature);
    form.append('filename', metadata.filename);
    form.append('chunk_index', metadata.chunkIndex.toString());
    form.append('total_chunks', metadata.totalChunks.toString());
    if (metadata.fileType) {
      form.append('file_type', metadata.fileType);
    }
    form.append('chunk', chunk, {
      filename: `chunk_${metadata.chunkIndex}`
    });

    await this.axios.post('/upload_dataset_chunk', form, {
      headers: form.getHeaders()
    });
  }

  // Story Protocol
  async getStoryIPAssets(): Promise<IPAsset[]> {
    try {
      const signature = await this.getSignature();
      Logger.debug('Calling get_story_ip_assets...');

      const response = await this.axios.get('/get_story_ip_assets', {
        params: { user_signature: signature }
      });

      if (response.data.status === 'Success') {
        // The API returns story_ips[] and ip_assets[] arrays, combine them
        const storyIPs = response.data.story_ips || [];
        const ipAssets = response.data.ip_assets || [];
        const allAssets = [...storyIPs, ...ipAssets];

        Logger.debug(`✅ Found ${allAssets.length} Story IP assets (${storyIPs.length} story_ips + ${ipAssets.length} ip_assets)`);
        return allAssets;
      }

      Logger.debug('⚠️ get_story_ip_assets returned non-success status');
      return [];
    } catch (error) {
      Logger.debug(`❌ Error fetching Story IP assets: ${error}`);
      return [];
    }
  }

  // Avalanche Biosamples
  async getAvalancheBiosamples(): Promise<any[]> {
    try {
      Logger.debug('Calling /biosamples?chainID=43113...');

      const response = await this.axios.get('/biosamples', {
        params: { chainID: 43113 }
      });

      let allBiosamples: any[] = [];
      if (Array.isArray(response.data)) {
        allBiosamples = response.data;
      } else if (response.data.biosamples && Array.isArray(response.data.biosamples)) {
        allBiosamples = response.data.biosamples;
      } else if (response.data.data && Array.isArray(response.data.data)) {
        allBiosamples = response.data.data;
      }

      // Filter for user's biosamples (we'll need wallet address)
      const creds = await this.credManager.loadCredentials();
      const userWallet = creds?.wallet_address?.toLowerCase();

      const userBiosamples = userWallet
        ? allBiosamples.filter(b => b.owner_address?.toLowerCase() === userWallet)
        : [];

      Logger.debug(`✅ Found ${userBiosamples.length} Avalanche biosamples`);
      return userBiosamples;
    } catch (error) {
      Logger.debug(`❌ Error fetching Avalanche biosamples: ${error}`);
      return [];
    }
  }

  async mintVariantsStoryNFT(metadata: {
    filename: string;
    s3_path?: string;
    ipfs_hash?: string;
    collection_address?: string;
  }): Promise<{ ipId: string; txHash: string }> {
    const signature = await this.getSignature();
    const response = await this.axios.post<ApiResponse>('/mint_variants_story_nft', {
      user_signature: signature,
      ...metadata
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data;
    }
    throw new Error('Failed to mint NFT');
  }

  // Biosamples
  async getMyActiveBiosamples(): Promise<Biosample[]> {
    const signature = await this.getSignature();
    const response = await this.axios.get<ApiResponse<Biosample[]>>('/my_active_biosamples', {
      params: { user_signature: signature }
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || [];
    }
    throw new Error('Failed to get biosamples');
  }

  async getBiosampleDetails(serial: string): Promise<Biosample> {
    const response = await this.axios.get<ApiResponse<Biosample>>('/biosample_details', {
      params: { biosample_serial: serial }
    });

    if (response.data.status === 'Success' && response.data.status_details?.data) {
      return response.data.status_details.data;
    }
    throw new Error('Failed to get biosample details');
  }

  // BioIP specific endpoints
  async getMyBioIPs(): Promise<any[]> {
    try {
      const signature = await this.getSignature();
      const response = await this.axios.get('/api_bioip/get_my_bioips', {
        params: { user_signature: signature }
      });
      return response.data.status_details?.bioips || response.data.bioips || response.data.data || [];
    } catch (error) {
      console.error('Error fetching BioIPs:', error);
      return [];
    }
  }

  async getMyGrantedBioIPs(): Promise<any[]> {
    try {
      const signature = await this.getSignature();

      // Debug logging to diagnose granted files issue
      Logger.debug('Calling get_my_granted_bioips...');
      Logger.debug(`Signature preview: ${signature.substring(0, 30)}...`);

      const response = await this.axios.get('/api_bioip/get_my_granted_bioips', {
        params: { user_signature: signature }
      });

      Logger.debug(`API Response status: ${response.data.status}`);
      Logger.debug(`Full response: ${JSON.stringify(response.data, null, 2)}`);

      const granted = response.data.status_details?.granted_bioips || response.data.granted_bioips || [];
      Logger.debug(`Parsed granted BioIPs count: ${granted.length}`);

      if (granted.length > 0) {
        Logger.debug(`First granted file: ${JSON.stringify(granted[0], null, 2)}`);
      }

      return granted;
    } catch (error: any) {
      Logger.debug(`Error fetching granted BioIPs: ${error}`);
      if (error?.response) {
        Logger.debug(`Error response: ${JSON.stringify(error.response.data)}`);
      }
      return [];
    }
  }

  async getBioIPDownloadURL(ipId: string): Promise<any> {
    const signature = await this.getSignature();

    // Use check_my_access endpoint instead - it's simpler and handles licensed access
    Logger.debug(`Checking access for IP Asset ${ipId}`);
    Logger.debug(`User signature: ${signature.substring(0, 20)}...`);

    const response = await this.axios.get('/api_bioip/check_my_access', {
      params: {
        user_signature: signature,
        ip_id: ipId
      }
    });

    Logger.debug(`Response status: ${response.data.status}`);
    Logger.debug(`Full response: ${JSON.stringify(response.data, null, 2)}`);

    if (response.data.status === 'Success' && response.data.status_details) {
      const details = response.data.status_details;

      if (!details.has_access) {
        throw new Error(details.reason || 'Access denied to this BioIP asset');
      }

      // Return in expected format
      return {
        access_granted: true,
        presigned_url: details.presigned_url,
        s3_path: details.s3_path,
        filename: details.filename || details.file_name
      };
    }
    throw new Error(response.data.status_details?.message || 'Failed to check access');
  }

  // Story PIL Access Control (GDPR Consent via License Tokens)
  async requestLicenseToken(ipId: string, licenseType: string = 'non-commercial', message?: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/api_bioip/request_license_token', {
      user_signature: signature,
      ip_id: ipId,
      license_type: licenseType,
      message: message || 'Request access for research purposes'
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.status_details?.message || 'License token request failed');
  }

  async grantLicenseToken(requestId: string, receiverWallet: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/api_bioip/grant_license_token', {
      user_signature: signature,
      request_id: requestId,
      receiver_wallet: receiverWallet
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.status_details?.message || 'License token minting failed');
  }

  async directGrantLicenseToken(ipId: string, receiverWallet: string, licenseType: string = 'non-commercial'): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/api_bioip/direct_grant_license_token', {
      user_signature: signature,
      ip_id: ipId,
      receiver_wallet: receiverWallet,
      license_type: licenseType
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.status_details?.message || 'Direct grant failed');
  }

  async revokeLicenseToken(ipId: string, receiverWallet: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/api_bioip/revoke_license_token', {
      user_signature: signature,
      ip_id: ipId,
      receiver_wallet: receiverWallet
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.status_details?.message || 'License token revocation failed');
  }

  async getPendingLicenseRequests(ipId?: string): Promise<any[]> {
    try {
      const signature = await this.getSignature();
      const params: any = { user_signature: signature };
      if (ipId) {
        params.ip_id = ipId;
      }
      const response = await this.axios.get('/api_bioip/get_pending_license_requests', { params });
      return response.data.status_details?.requests || response.data.status_details?.data?.requests || response.data.requests || [];
    } catch (error) {
      return [];
    }
  }

  async getActiveLicenseTokens(ipId?: string): Promise<any[]> {
    try {
      const signature = await this.getSignature();
      const params: any = { user_signature: signature };
      if (ipId) {
        params.ip_id = ipId;
      }
      const response = await this.axios.get('/api_bioip/get_active_license_tokens', { params });
      return response.data.status_details?.tokens || response.data.status_details?.data?.tokens || response.data.tokens || [];
    } catch (error) {
      return [];
    }
  }

  async checkMyAccess(ipId: string): Promise<any> {
    try {
      const signature = await this.getSignature();
      const response = await this.axios.get('/api_bioip/check_my_access', {
        params: {
          user_signature: signature,
          ip_id: ipId
        }
      });
      return response.data.status_details || response.data;
    } catch (error) {
      throw new Error('Failed to check access');
    }
  }

  // Legacy biosample methods (kept for backward compatibility)
  async requestBiosampleAccess(bioassetSerial: string, message?: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/request_biosample', {
      user_signature: signature,
      biosample_serial: bioassetSerial,
      message: message || 'Request access for research purposes'
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.status_details?.message || 'Access request failed');
  }

  async approveBiosampleRequest(requestId: string, permitteeAddress: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/approve_biosample_request', {
      user_signature: signature,
      request_id: requestId,
      permittee_address: permitteeAddress
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.status_details?.message || 'Approval failed');
  }

  async revokeBiosampleAccess(bioassetSerial: string, permitteeAddress: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/revoke_biosample_request', {
      user_signature: signature,
      biosample_serial: bioassetSerial,
      permittee_address: permitteeAddress
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.status_details?.message || 'Revocation failed');
  }

  async getPermittees(bioassetSerial: string): Promise<any[]> {
    try {
      const response = await this.axios.get('/permittees', {
        params: { serial: bioassetSerial }
      });
      return response.data.permittees || response.data.data || [];
    } catch (error) {
      return [];
    }
  }

  async getMyPermissions(): Promise<any[]> {
    try {
      const signature = await this.getSignature();
      const response = await this.axios.get('/get_permitted_biosamples', {
        params: { signature }
      });
      return response.data.biosamples || response.data.data || [];
    } catch (error) {
      return [];
    }
  }

  // VCF Annotator endpoints
  async getVCFFiles(): Promise<any[]> {
    try {
      const signature = await this.getSignature();
      const response = await this.axios.get('/api_vcf_annotator/get_vcf_file_routes', {
        params: { user_signature: signature }
      });
      return response.data.files || response.data.data || [];
    } catch (error) {
      return [];
    }
  }

  // AlphaGenome endpoints
  async getMyAnalyses(): Promise<any[]> {
    try {
      const signature = await this.getSignature();
      const response = await this.axios.get('/api_alphagenome/get_my_analyses', {
        params: { user_signature: signature }
      });
      return response.data.analyses || response.data.data || [];
    } catch (error) {
      return [];
    }
  }

  // BioOS endpoints - Research Job Management
  async createBioOSJob(prompt: string, inputFiles: any[], pipeline?: any, metadata?: any): Promise<{ job_id: string; status: string; message: string }> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/api_bioos/create_job', {
      user_signature: signature,
      prompt,
      input_files: inputFiles,
      pipeline,
      metadata
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || {};
    }
    throw new Error(response.data.status_details?.error || 'Failed to create job');
  }

  async getBioOSJobStatus(jobId: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.get('/api_bioos/job_status', {
      params: {
        user_signature: signature,
        job_id: jobId
      }
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || {};
    }
    throw new Error(response.data.status_details?.error || 'Failed to get job status');
  }

  async getBioOSJobResults(jobId: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.get('/api_bioos/job_results', {
      params: {
        user_signature: signature,
        job_id: jobId
      }
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || {};
    }
    throw new Error(response.data.status_details?.error || 'Failed to get job results');
  }

  async getBioOSPipelineList(): Promise<any> {
    const response = await this.axios.get('/api_bioos/pipeline_list');

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || {};
    }
    throw new Error('Failed to get pipeline list');
  }

  async getBioOSUserJobs(): Promise<any[]> {
    const signature = await this.getSignature();
    const response = await this.axios.get('/api_bioos/user_jobs', {
      params: { user_signature: signature }
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data?.jobs || [];
    }
    throw new Error(response.data.status_details?.error || 'Failed to get user jobs');
  }

  // ========================================
  // Dual NFT System - BioCID + Story Protocol
  // ========================================

  /**
   * Get approved research labs from registry
   * Labs must be verified to receive BioNFT-licensed genomic data
   */
  async getApprovedLabs(): Promise<any[]> {
    try {
      Logger.debug('Fetching approved labs from registry...');
      const response = await this.axios.get('/approved_labs');

      if (response.data.status === 'Success') {
        return response.data.labs || response.data.data || [];
      }
      return [];
    } catch (error) {
      Logger.debug(`Error fetching approved labs: ${error}`);
      return [];
    }
  }

  /**
   * Mint BioCID NFT on Sequentias Network
   * BioCID provides decentralized location addressing via Biorouter protocol
   */
  async mintSequentiasBioCID(params: {
    filename: string;
    file_type: string;
    s3_path: string;
  }): Promise<any> {
    const signature = await this.getSignature();
    Logger.debug('Minting BioCID on Sequentias Network...');

    const response = await this.axios.post('/api_sequentias/mint_biocid', {
      user_signature: signature,
      filename: params.filename,
      file_type: params.file_type,
      s3_path: params.s3_path
    });

    if (response.data.status === 'Success') {
      return response.data.data || response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.message || 'Failed to mint BioCID');
  }

  /**
   * Register IP Asset on Story Protocol with BioCID reference
   * Links Story Protocol IP licensing to Sequentias location addressing
   */
  async registerIPAssetWithBiocid(params: {
    biocid: string;
    filename: string;
    file_type: string;
  }): Promise<any> {
    const signature = await this.getSignature();
    Logger.debug('Registering IP Asset on Story Protocol...');

    const response = await this.axios.post('/api_bioip/register_with_biocid', {
      user_signature: signature,
      biocid: params.biocid,
      filename: params.filename,
      file_type: params.file_type
    });

    if (response.data.status === 'Success') {
      return response.data.data || response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.message || 'Failed to register IP Asset');
  }

  /**
   * Attach PIL (Programmable IP License) terms to IP Asset
   * Enables license token minting for authorized labs
   */
  async attachLicenseTerms(params: {
    ip_id: string;
    license_type: 'non-commercial' | 'commercial' | 'commercial-remix';
  }): Promise<any> {
    const signature = await this.getSignature();
    Logger.debug(`Attaching ${params.license_type} license terms...`);

    const response = await this.axios.post('/api_bioip/attach_license_terms', {
      user_signature: signature,
      ip_id: params.ip_id,
      license_type: params.license_type
    });

    if (response.data.status === 'Success') {
      return response.data.data || response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.message || 'Failed to attach license terms');
  }

  /**
   * Share biofile with approved lab by minting license token
   * Creates NFT-gated access for GDPR-compliant data sharing
   */
  async shareWithLab(params: {
    ip_id: string;
    lab_wallet: string;
    license_type: 'non-commercial' | 'commercial' | 'commercial-remix';
  }): Promise<any> {
    const signature = await this.getSignature();
    Logger.debug(`Sharing IP Asset ${params.ip_id} with lab ${params.lab_wallet}...`);

    const response = await this.axios.post('/api_bioip/share_with_lab', {
      user_signature: signature,
      ip_id: params.ip_id,
      lab_wallet: params.lab_wallet,
      license_type: params.license_type
    });

    if (response.data.status === 'Success') {
      return response.data.data || response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.message || 'Failed to share with lab');
  }

  /**
   * Check if file already has BioCID
   * Prevents duplicate minting during share process
   */
  async checkExistingBiocid(filename: string): Promise<any | null> {
    try {
      const signature = await this.getSignature();
      Logger.debug(`Checking for existing BioCID: ${filename}`);

      const response = await this.axios.get('/api_sequentias/check_biocid', {
        params: {
          user_signature: signature,
          filename
        }
      });

      if (response.data.status === 'Success' && response.data.exists) {
        return response.data.data;
      }
      return null;
    } catch (error) {
      Logger.debug(`No existing BioCID found for ${filename}`);
      return null;
    }
  }
}