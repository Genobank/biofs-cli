import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { CONFIG } from '../config/constants';
import { CredentialsManager } from '../auth/credentials';
import { ApiResponse, FileInfo, FileWithURL, IPAsset, Biosample } from '../../types/api';

export class GenoBankAPIClient {
  private static instance: GenoBankAPIClient;
  private axios: AxiosInstance;
  private credManager: CredentialsManager;

  private constructor() {
    this.credManager = CredentialsManager.getInstance();
    this.axios = axios.create({
      baseURL: CONFIG.API_BASE_URL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }

  static getInstance(): GenoBankAPIClient {
    if (!GenoBankAPIClient.instance) {
      GenoBankAPIClient.instance = new GenoBankAPIClient();
    }
    return GenoBankAPIClient.instance;
  }

  private async getSignature(): Promise<string> {
    const creds = await this.credManager.loadCredentials();
    if (!creds) {
      throw new Error('Not authenticated. Please run "genobank login" first.');
    }
    return creds.user_signature;
  }

  // Authentication
  async recover(signature: string): Promise<{ wallet: string }> {
    const response = await this.axios.get('/recover', {
      params: { signature }
    });
    return response.data;
  }

  async validateRootUser(signature: string): Promise<boolean> {
    try {
      const response = await this.axios.get('/validate_root_user', {
        params: { signature }
      });
      return response.data.status === 'Success';
    } catch {
      return false;
    }
  }

  // Files
  async getMyUploadedFileList(): Promise<FileInfo[]> {
    const signature = await this.getSignature();
    const response = await this.axios.get<ApiResponse<FileInfo[]>>('/get_my_uploaded_file_list', {
      params: { user_signature: signature }
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || [];
    }
    throw new Error(response.data.status_details?.message || 'Failed to get file list');
  }

  async getMyUploadedFilesUrls(filter?: string): Promise<FileWithURL[]> {
    const signature = await this.getSignature();
    const params: any = { user_signature: signature };
    if (filter) params._filter = filter;

    try {
      const response = await this.axios.get<ApiResponse<FileWithURL[]>>('/get_my_uploaded_files_urls', {
        params
      });

      if (response.data.status === 'Success') {
        return response.data.status_details?.data || [];
      }
      // Return empty array if failed instead of throwing
      return [];
    } catch (error) {
      // Return empty array on error - user might not have files yet
      return [];
    }
  }

  async getPresignedLink(s3Path: string): Promise<string> {
    const signature = await this.getSignature();
    const response = await this.axios.post<ApiResponse<{ url: string }>>('/get_presigned_link', {
      user_signature: signature,
      s3_path: s3Path
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data?.url || '';
    }
    throw new Error('Failed to get presigned URL');
  }

  async streamFile(filename: string, fileType?: string): Promise<string> {
    const signature = await this.getSignature();
    const params: any = {
      user_signature: signature,
      filename
    };
    if (fileType) params.file_type = fileType;

    // Return the stream URL
    return `${CONFIG.API_BASE_URL}/stream_file?${new URLSearchParams(params).toString()}`;
  }

  async uploadDatasetChunk(
    chunk: Buffer,
    metadata: {
      filename: string;
      chunkIndex: number;
      totalChunks: number;
      fileType?: string;
    }
  ): Promise<void> {
    const signature = await this.getSignature();
    const FormData = require('form-data');
    const form = new FormData();

    form.append('user_signature', signature);
    form.append('filename', metadata.filename);
    form.append('chunk_index', metadata.chunkIndex.toString());
    form.append('total_chunks', metadata.totalChunks.toString());
    if (metadata.fileType) {
      form.append('file_type', metadata.fileType);
    }
    form.append('chunk', chunk, {
      filename: `chunk_${metadata.chunkIndex}`
    });

    await this.axios.post('/upload_dataset_chunk', form, {
      headers: form.getHeaders()
    });
  }

  // Story Protocol
  async getStoryIPAssets(): Promise<IPAsset[]> {
    const signature = await this.getSignature();
    const response = await this.axios.get<ApiResponse<IPAsset[]>>('/get_story_ip_assets', {
      params: { user_signature: signature }
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || [];
    }
    throw new Error('Failed to get Story IP assets');
  }

  async mintVariantsStoryNFT(metadata: {
    filename: string;
    s3_path?: string;
    ipfs_hash?: string;
    collection_address?: string;
  }): Promise<{ ipId: string; txHash: string }> {
    const signature = await this.getSignature();
    const response = await this.axios.post<ApiResponse>('/mint_variants_story_nft', {
      user_signature: signature,
      ...metadata
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data;
    }
    throw new Error('Failed to mint NFT');
  }

  // Biosamples
  async getMyActiveBiosamples(): Promise<Biosample[]> {
    const signature = await this.getSignature();
    const response = await this.axios.get<ApiResponse<Biosample[]>>('/my_active_biosamples', {
      params: { user_signature: signature }
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || [];
    }
    throw new Error('Failed to get biosamples');
  }

  async getBiosampleDetails(serial: string): Promise<Biosample> {
    const response = await this.axios.get<ApiResponse<Biosample>>('/biosample_details', {
      params: { biosample_serial: serial }
    });

    if (response.data.status === 'Success' && response.data.status_details?.data) {
      return response.data.status_details.data;
    }
    throw new Error('Failed to get biosample details');
  }

  // BioIP specific endpoints
  async getMyBioIPs(): Promise<any[]> {
    try {
      const signature = await this.getSignature();
      const response = await this.axios.get('/api_bioip/get_my_bioips', {
        params: { user_signature: signature }
      });
      return response.data.status_details?.bioips || response.data.bioips || response.data.data || [];
    } catch (error) {
      console.error('Error fetching BioIPs:', error);
      return [];
    }
  }

  async getBioIPDownloadURL(ipId: string): Promise<any> {
    const signature = await this.getSignature();

    // Use check_my_access endpoint instead - it's simpler and handles licensed access
    console.log(`üîç DEBUG API: Checking access for IP Asset ${ipId}`);
    console.log(`üîç DEBUG API: User signature: ${signature.substring(0, 20)}...`);

    const response = await this.axios.get('/api_bioip/check_my_access', {
      params: {
        user_signature: signature,
        ip_id: ipId
      }
    });

    console.log(`üîç DEBUG API: Response status: ${response.data.status}`);
    console.log(`üîç DEBUG API: Full response:`, JSON.stringify(response.data, null, 2));

    if (response.data.status === 'Success' && response.data.status_details) {
      const details = response.data.status_details;

      if (!details.has_access) {
        throw new Error(details.reason || 'Access denied to this BioIP asset');
      }

      // Return in expected format
      return {
        access_granted: true,
        presigned_url: details.presigned_url,
        s3_path: details.s3_path,
        filename: details.filename || details.file_name
      };
    }
    throw new Error(response.data.status_details?.message || 'Failed to check access');
  }

  // Story PIL Access Control (GDPR Consent via License Tokens)
  async requestLicenseToken(ipId: string, licenseType: string = 'non-commercial', message?: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/api_bioip/request_license_token', {
      user_signature: signature,
      ip_id: ipId,
      license_type: licenseType,
      message: message || 'Request access for research purposes'
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.status_details?.message || 'License token request failed');
  }

  async grantLicenseToken(requestId: string, receiverWallet: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/api_bioip/grant_license_token', {
      user_signature: signature,
      request_id: requestId,
      receiver_wallet: receiverWallet
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.status_details?.message || 'License token minting failed');
  }

  async revokeLicenseToken(ipId: string, receiverWallet: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/api_bioip/revoke_license_token', {
      user_signature: signature,
      ip_id: ipId,
      receiver_wallet: receiverWallet
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.status_details?.message || 'License token revocation failed');
  }

  async getPendingLicenseRequests(ipId?: string): Promise<any[]> {
    try {
      const signature = await this.getSignature();
      const params: any = { user_signature: signature };
      if (ipId) {
        params.ip_id = ipId;
      }
      const response = await this.axios.get('/api_bioip/get_pending_license_requests', { params });
      return response.data.status_details?.requests || response.data.status_details?.data?.requests || response.data.requests || [];
    } catch (error) {
      return [];
    }
  }

  async getActiveLicenseTokens(ipId?: string): Promise<any[]> {
    try {
      const signature = await this.getSignature();
      const params: any = { user_signature: signature };
      if (ipId) {
        params.ip_id = ipId;
      }
      const response = await this.axios.get('/api_bioip/get_active_license_tokens', { params });
      return response.data.status_details?.tokens || response.data.status_details?.data?.tokens || response.data.tokens || [];
    } catch (error) {
      return [];
    }
  }

  async checkMyAccess(ipId: string): Promise<any> {
    try {
      const signature = await this.getSignature();
      const response = await this.axios.get('/api_bioip/check_my_access', {
        params: {
          user_signature: signature,
          ip_id: ipId
        }
      });
      return response.data.status_details || response.data;
    } catch (error) {
      throw new Error('Failed to check access');
    }
  }

  // Legacy biosample methods (kept for backward compatibility)
  async requestBiosampleAccess(bioassetSerial: string, message?: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/request_biosample', {
      user_signature: signature,
      biosample_serial: bioassetSerial,
      message: message || 'Request access for research purposes'
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.status_details?.message || 'Access request failed');
  }

  async approveBiosampleRequest(requestId: string, permitteeAddress: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/approve_biosample_request', {
      user_signature: signature,
      request_id: requestId,
      permittee_address: permitteeAddress
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.status_details?.message || 'Approval failed');
  }

  async revokeBiosampleAccess(bioassetSerial: string, permitteeAddress: string): Promise<any> {
    const signature = await this.getSignature();
    const response = await this.axios.post('/revoke_biosample_request', {
      user_signature: signature,
      biosample_serial: bioassetSerial,
      permittee_address: permitteeAddress
    });

    if (response.data.status === 'Success') {
      return response.data.status_details?.data || response.data;
    }
    throw new Error(response.data.status_details?.message || 'Revocation failed');
  }

  async getPermittees(bioassetSerial: string): Promise<any[]> {
    try {
      const response = await this.axios.get('/permittees', {
        params: { serial: bioassetSerial }
      });
      return response.data.permittees || response.data.data || [];
    } catch (error) {
      return [];
    }
  }

  async getMyPermissions(): Promise<any[]> {
    try {
      const signature = await this.getSignature();
      const response = await this.axios.get('/get_permitted_biosamples', {
        params: { signature }
      });
      return response.data.biosamples || response.data.data || [];
    } catch (error) {
      return [];
    }
  }

  // VCF Annotator endpoints
  async getVCFFiles(): Promise<any[]> {
    try {
      const signature = await this.getSignature();
      const response = await this.axios.get('/api_vcf_annotator/get_vcf_file_routes', {
        params: { user_signature: signature }
      });
      return response.data.files || response.data.data || [];
    } catch (error) {
      return [];
    }
  }

  // AlphaGenome endpoints
  async getMyAnalyses(): Promise<any[]> {
    try {
      const signature = await this.getSignature();
      const response = await this.axios.get('/api_alphagenome/get_my_analyses', {
        params: { user_signature: signature }
      });
      return response.data.analyses || response.data.data || [];
    } catch (error) {
      return [];
    }
  }
}